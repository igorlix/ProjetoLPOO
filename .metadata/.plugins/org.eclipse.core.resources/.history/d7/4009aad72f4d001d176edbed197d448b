package controle;

import javax.swing.*;

import modelos.blocos;

public class movimento {
    public static final int movimento = 0;//velocidade do movimento dos blocos//
    public static int fps = blocos.WIDTH;

    public static void animateblocos(blocos blocos, blocos emptyblocos, JPanel panel) {
        String direction = detectMovementDirection(blocos, emptyblocos);

        int prevPosX = blocos.getX();
        int prevPosY = blocos.getY();

        switch (direction) {
            case "LEFT":
                new Thread(() -> {
                    for (int i = 0; i < fps; i++) {
                        try {
                            Thread.sleep(movimento);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        blocos.setX(blocos.getX() - 1);
                        moveEmptyblocos(emptyblocos, prevPosX, prevPosY);
                        panel.repaint();
                    }
                }).start();
                break;
            case "RIGHT":
                new Thread(() -> {
                    for (int i = 0; i < fps; i++) {
                        try {
                            Thread.sleep(movimento);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        blocos.setX(blocos.getX() + modelos.blocos.WIDTH / fps);
                        moveEmptyblocos(emptyblocos, prevPosX, prevPosY);
                        panel.repaint();
                    }
                }).start();
                break;
            case "UP":
                new Thread(() -> {
                    for (int i = 0; i < fps; i++) {
                        try {
                            Thread.sleep(movimento);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        moveEmptyblocos(emptyblocos, prevPosX, prevPosY);
                        blocos.setY(blocos.getY() - modelos.blocos.HEIGHT / fps);
                        panel.repaint();
                    }
                }).start();
                break;
            case "DOWN":
                new Thread(() -> {
                    for (int i = 0; i < fps; i++) {
                        try {
                            Thread.sleep(movimento);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        blocos.setY(blocos.getY() + modelos.blocos.HEIGHT / fps);
                        moveEmptyblocos(emptyblocos, prevPosX, prevPosY);
                        panel.repaint();
                    }
                }).start();
                break;
        }
    }

    private static void moveEmptyblocos(blocos emptyblocos, int prevPosX, int prevPosY) {
        emptyblocos.setX(prevPosX);
        emptyblocos.setY(prevPosY);
    }

    public static String detectMovementDirection(blocos blocos, blocos emptyblocos) {

        if (blocos.getX() > emptyblocos.getX() && blocos.getY() == emptyblocos.getY())
            return "LEFT";

        if (blocos.getX() < emptyblocos.getX() && blocos.getY() == emptyblocos.getY())
            return "RIGHT";

        if (blocos.getY() > emptyblocos.getY() && blocos.getX() == emptyblocos.getX())
            return "UP";

        if (blocos.getY() < emptyblocos.getY() && blocos.getX() == emptyblocos.getX())
            return "DOWN";

        return "UNKNOWN";
    }

}